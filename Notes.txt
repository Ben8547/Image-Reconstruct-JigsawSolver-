2-17-2026 13:50 : The simulated annealing approach, while working, seems to be getting stuck in local minima. While one of the hallmarks of this method is that it should not get stuck in local minima, it seems that here the local minima trap due to the method of system perturbation. I chose to define a new grid by swapping two random points in the grid, so while the program has demonstrated its ability to match several pairs of pieces, since it cannot move more than one tile at a time, moving one of the paired tiles into its correct position would almost certainly increase the system energy significantly because we cannot move the tiles in their pairs so the stabilizing interaction would be lost. We could probably play around with the temperature schedule, but I think that this probably won't work well on its own. We will need to use some other established method to match regions. Then perhaps we can add the simulated annealing back in at some point.

2-17-2026 14:25 : Found papers on genetic algorithms; decided to try implementing a genetic algorithm.

2-17-2026: 15:20 : I'm actually pretty impressed that I managed to come up with one of the more optimal objective functions on my own and came up with the same image representation scheme as the people in most of these papers.


2-18-2026 12:14 : The genetic algorithm that I'm trying to implement was almost completed last night, but coding the crossing function is turning out to be technical challenge. I'm revisiting the pure annealing methods with an additional idea. I think that the reason it got stuck before was because it would only move a single pair of pieces at a time. Instead, I think that we should choose the perturbation from a list of random possibilities that include larger rearrangements such as cutting the entire space into large segments and shifting them clockwise or swapping locations of entire swaths of the domain. This would allow pieces that are already paired to move together and we would no longer be trapped in a local minimum.

2-18-2026 13:08 : This didn't seem to really make any difference at all. We may need to look into those local greedy algorithms. I could think that they might give insight into what operations would be most effective given a certain solution state.

2-18-2026 14:53 : Back to working on the genetic algorithm.

2-18-2026 17:33 : simplified crossing algorithm sans the mutations is not complete. Will run a small trial to fish for bugs

2-18-2026 23:36 : finished the crossing algorithm except the mutations; will add that next. The speed is surprisingly quick. I though it would be dreadfully slow given the shear number of array operations which are probably not as efficient as they could be. Jaiz recommended replacing lists with sets as I don't care about order in some of them, and the lookup time is faster. On another note, 5 generations gets us to an energy of 189106.09901162336 which is definitely worse than my simulated annealing, so it might be worth, instead of seeding with 1000 random samples from the solution space, seeding with 10, running simulated annealing and then choosing the first generation parent from those 10, thus we start at about 160000 on the energy scale. Then I'll add in mutation and see how that does. 
Another issue that I thing plagues this particular application and not the puzzle that the papers are working with is that the Manga page has a lot of random white space so the algorithms tend to want to stick dialog boxes together even it they are from the wrong panels.

2-18-2026 23:58 : for the record, scale=0.999 and T0=200 reliably gets us to an energy of about 165000 in a decent amount of time (about 10 seconds) (annealing) - will probably use these settings for seeding the genetic algorithm.

2-19-2026 0:39 : It seems that the fitness function is actually trying to maximize energy, which is certainly not what we want; I keep seeing the energies get father from 0. 

2-19-2026 1:13 : above issue is fixed; though now it is obvious that the genetic algorithm cannot improve upon simulated annealing in its current form.

2-19-2026 1:26 : added a program that can create a puzzle out of any image - I want to see if the white space in the Manga I've been using is a big of an issue as I think it is.

2-19-2026 1:28 : custom squirrel puzzle finished, It doesn't seem to have done any better. I think that I'll add the mutations now and try that instead. Maybe that is the piece that we are missing. (maybe tomorrow actually)

2-19-2026 2:01 : I'll just let it run overnight and see where se get to.

2-19-2026 11:34 : Ran two 100 generation trial last night on the squirrel puzzle. One the neaaling mutation and one without. Neither performed well. I think I will need to implement the best buddies. I want to see if that makes a different. If it doesn't I might need to reread the paper to see if I misinterpreted anything.

2-19-2026 11:39 : I had the idea to see what the energy of the original image of the squirrel was. It seems to be nearly 7000; so my programs were actually finding minima, its just that for whatever reason, the original image isn't a minimum of my energy function which is really weird. I'll test another puzzle I think. An image of a Zebra perhaps - very distinct colors.

2-19-2026 11:46 : Original Zebra has an energy of about 87757.54583770488. After running simulated annealing on the original Zebra (not even a puzzle version) the energy becomes 32767.698903254175. Looking at the output image, we see the body of the Zebra has been dispersed around the edges of the diagram, while the body of the zebra got paused to the boarder so that all of the white space in the background could have maximal contact. I think this is an issue because the papers are using color images and I'm using grayscale and their backgrounds are rarely monochromatic. My earlier idea about the dialog boxes seems to have been correct.

2-19-2026 11:56 : The rainbow flower image original has an energy of 120255.8291043487. After annealing it is reduced to 75015.15926847246. I honestly don't know what the flower is doing, it seems in everyway like the energy should be worse. It is quite clear that we need a different energy function; my immediate idea is to penalize whitespace, other otherwise exclude whitespace from the computation, but this won't solve whatever is going on with the flower and the squirrel.

2-19-2026 12:14 : Decided to change the computability functions to intake colored images. I want to see if this helps with the white space problem or if it makes solving puzzles like the flower and the squirrel easier.

2-19-2026 1:31 : Implemented a color version for simulated annealing. It just tries to put similar colors together so you get clumps of red and clumps of blue and that's it. It doesn't actually try to preserve the structure.

2-19-2026 2:05 : Implemented an energy computer; my suspicion that some randomized images have lower energies than the originals using the similar difference norm is True. We thus need to revise our energy function. It has also been pointed out to me that in my Markov chain I recompute the energies each time, but it would be much quicker to simply recompute the few affected terms. Thus I will work on implementing that next.

2-19-2026 18:09 : I spuddled on improving the computational efficiency of the Markov step; tried to only recalculate local energies. I wrote a bunch of code, but ended up with negative energies which should not be possible. Thus I gave up after several hours and commented out what I wrote and went back to global energy calc. If we want to solve larger puzzles at some point I need to revisit this. In other news, using the L2 norm, the squirrel puzzle has lower energy than the original. When I switched to np.mean((x-y)**2) the original now has lower energy. This is ideal so I am changing the energy function to this permanently (unless I find a better energy function).

2-19-2026 19:46 : Eventually when I rewrite these codes in a more efficient way, it would be worth caching local energies so that I can target movement in annealing to areas with high local energy. I think that for tomorrow, next steps are to work on caching the energies of each tile pairing upfront in an array and then using the table to make informed movement decisions. Using this with the annealing makes it less random and could help to increase the efficacy of the algorithm.

2-19-2026 19:52 : Final note for today because I need to work on Joel's project, running the pure annealing algorithm at a geometric decay rate of 0.99999 yielded a final energy of 5718.436868686868.

2-20-2026 17:55 : I stated writing a new file called version3.py today in which I attempt to improve upon the pure annealing method. This will mainly be a running list of changes I am making for reference:
	grid is now padded with an extra layer of -1s so that we can index the array in a vectorized way without having to worry about the ; this will change how I have to do my indexing since every row and column index is not 1 more.
	tiles (the list of dictionaries) was replaced with an array of dictionaries. I would have done this before if I'd know you could have an array of dictionaries.
	We cached every possible interaction energy upfront. This should save computation time.
	Rewrote most functions in a vectorized version - this was difficult as I am not used to thinking in vectorization at all.

2-21-2026 0:19 : I think there was an error in the computation of the original energy functions where the double loop meant that the left energies in the top row and top energies in the left column were not counted, I have fixed this in the vectorized version. - Looking back on the outputs there do seem to be fewer matches on the left and top which makes sense in retrospect.
	

